(*!m2pim*)

(* *************************************************************************
 * Grammar Tool for LL(1) Grammars
 *
 * Copyright (C) 2018 Benjamin Kowarsch
 *
 * Synopsis
 *
 * GLL is a tool to verify and visualise LL(1) grammars.  It parses EBNF
 * specifications of grammars, calculates FIRST and FOLLOW sets, reports
 * any LL(1) violations and generates (railroad) syntax diagrams.
 *
 * File
 *
 * MatchLex.def
 *
 * Interface of EBNF Lexer Support Library.
 *
 * License
 *
 * GLL is free software: you can redistribute it and/or modify it under
 * the terms of the GNU Lesser General Public License Version 2 (LGPL2)
 * as published by the Free Software Foundation.
 *
 * GLL is distributed in the hope that it will be useful,  but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Refer to the license for details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with GLL.  If not, please visit <http://www.gnu.org/licenses/>.
 * ************************************************************************* *)

DEFINITION MODULE MatchLex;

(* Lexer Support Library for EBNF Lexer *)

FROM Token IMPORT TokenT;
FROM Source IMPORT SourceT;
FROM Diagnostic IMPORT DiagnosticT;


(* Semantic Symbols *)

(* ---------------------------------------------------------------------------
 * Procedure MatchLex.reswordOrIdent(source, symbol)
 * ---------------------------------------------------------------------------
 * Matches the input in source  to a reserved word or identifier.  If there is
 * a match, it consumes the symbol's lexeme in source, passes back the matched
 * symbol in symbol  and returns TRUE.  Otherwise, it does NOT consume any in-
 * put, passes back a diagnostic symbol and returns FALSE.
 * ---------------------------------------------------------------------------
 *)
PROCEDURE reswordOrIdent ( source : SourceT; VAR sym : SymbolT ) : BOOLEAN;


(* ---------------------------------------------------------------------------
 * Procedure MatchLex.quotedLiteral(source, symbol)
 * ---------------------------------------------------------------------------
 * Matches the input in source  to a  quoted literal.  If there is a match, it
 * consumes the symbol's lexeme  in source,  passes back the matched symbol in
 * symbol  and returns TRUE.  Otherwise, it does NOT consume the input, passes
 * back a diagnostic symbol and returns FALSE.
 * ---------------------------------------------------------------------------
 *)
PROCEDURE quotedLiteral ( source : SourceT; VAR sym : SymbolT ) : BOOLEAN;


(* ---------------------------------------------------------------------------
 * Procedure MatchLex.charCodeLiteral(source, symbol)
 * ---------------------------------------------------------------------------
 * Matches  the input  in source  to a  character code literal.  If there is a
 * match, it consumes the symbol's lexeme in source,  passes back  the matched
 * symbol  and returns TRUE.  Otherwise, it does NOT consume the input, passes
 * back a diagnostic symbol and returns FALSE.
 * ---------------------------------------------------------------------------
 *)
PROCEDURE charCodeLiteral ( source : SourceT; VAR sym : SymbolT ) : BOOLEAN;


(* Non-Semantic Symbols *)

(* ---------------------------------------------------------------------------
 * Procedure MatchLex.pragma(source, symbol)
 * ---------------------------------------------------------------------------
 * Matches the input in source to a pragma.  If there is a match,  it consumes
 * the symbol's lexeme in source,  passes back the matched symbol  and returns
 * TRUE.  If FALSE is passed in  for requireLexeme,  the  lexeme field  of the
 * passed back symbol will be set to NIL.  If there is  no match,  it does NOT
 * consume the input,  passes back a diagnostic symbol and returns FALSE.
 * ---------------------------------------------------------------------------
 *)
PROCEDURE pragma
  ( source : SourceT; requireLexeme : BOOLEAN; VAR sym : SymbolT ) : BOOLEAN;


(* ---------------------------------------------------------------------------
 * Procedure MatchLex.blockComment(source, symbol)
 * ---------------------------------------------------------------------------
 * Matches the input in source  to a  block comment.  If there is a match,  it
 * consumes the symbol's lexeme in source,  passes back the matched symbol and
 * returns TRUE.  If FALSE is passed in for requireLexeme, the lexeme field of
 * the passed back symbol will be set to NIL.  If there is  no match,  it does
 * NOT consume the input,  passes back a diagnostic symbol and returns FALSE.
 * ---------------------------------------------------------------------------
 *)
PROCEDURE blockComment
  ( source : SourceT; requireLexeme : BOOLEAN; VAR sym : SymbolT ) : BOOLEAN;


(* Disabled Code Sections *)

(* ---------------------------------------------------------------------------
 * Procedure MatchLex.blockComment(source, symbol)
 * ---------------------------------------------------------------------------
 * Matches the input in source to an opening disabled code block delimiter and
 * consumes the disabled code block, including its closing delimiter.
 * ---------------------------------------------------------------------------
 *)
PROCEDURE DisabledCodeBlock ( source : SourceT );


END MatchLex.
